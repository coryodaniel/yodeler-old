TODO
=======

  * Wiki page for SMS
  * Wiki page for Pusher
  * Wiki page for Mail, ActionMailer

Yodeler
=======

Spouting noise to whoever is listening.

When an event occurs notifications are created in your datastore for each user's subscription.

Features
========
  * i18n support
  * store notifications via ActiveRecord  
  * send notifications via sms
  * send notifications via email
  * benchmark event duration
  * flexible payloads


What's wrong with XMPP?
=======================

  Why don't you fly to Walmart on a rocket?

  Don't even say it's because you don't have a rocket.

  Why don't you kill ants with a bazooka?

  Nevermind, you get it.

Note
====

Top level app/ and config/ directories are for mounting into rails app. Not sure if a UI should be built or not. This
is the default app generated by the flag --mountable.


Usage
=====
```ruby
# in config/initializers/yodeler.rb
Yodeler.register :another_thousand_users
Yodeler.register :view_user do
  # You can configure a lot of how the notifications for this event works here

  # Name and description can be set for I18n support when rendering to
  # a web UI
  # I18n.t('yodeler.events.EVENT_KEY.name')
  # I18n.t('yodeler.events.EVENT_KEY.description')

  # Defaults to false, default batch size is 100 subscriptions
  async true, batch_size: 10, worker: My3rdPartyWorker # require 'yodeler/workers/yodel_worker'

  # send an email however you prefer to email
  email { |notification| 
    Mail.deliver do
      from     'ok-to-reply@example.com'
      to       notification.subscriber.email # Subscriber here is your 'user' model
      subject  "Yodeler Event: #{notification.event.name}"
      body     notification.message #I18n.t('yodeler.notifications.YOUR_EVENT_NAME.message', notification.event.payload)
    end
  }

  # send some sweet HTML5 websocket jazz however you prefer to do your HTML5 websocket jazz
  # NOTE: here you receive the event, not the notification
  websocket { |event|
    Pusher.trigger('yodeler', event.name, event.payload)
  }

  # send an sms however you prefer to sms
  sms { |notification|
    twilio_client.account.messages.create(
      :from => MY_TWILIO_NUMBER,
      :to => notification.subscriber.phone_number, #note subscriber here is your 'user' model
      :body => notification.message #I18n.t('yodeler.notifications.YOUR_EVENT_NAME.message', notification.event.payload)
    )   
  }

  dispatch_if{ |yodel_event|
    # all yodels dispatch for notification by default, you can do something fancy here to filter
    yodel_event.duration > 5.seconds
  }

  # You could technically add columns onto yodel_subscriptions table to allow additional customization
  #   specific to your app
  notify_if{ |yodel_subscription|

    yodel_subscription.wants_to_know_about_user_42? and yodel_subscription.yodel_event.payload[:user_id] == 42
    # or yodel_subscription.my_crazy_column_where_i_trust_users_to_input_javascript_functions_and_this_method_was_evaled_on_and_wraps_rubyracer(yodel_subscription.yodel_event.payload)
  }

  # to help clean up old notifications, each Yodel::Event that is registered
  #   can have its own rules for when to destroy notifications. This after save
  #   callback is called on each notification after save (obvi)
  destroy_notification_if{|notification|
    notification.state == :read and notification.created_at < 14.days.ago
  }

  # destroys the notification when it enters the given state
  # destroy_notification_if :my_custom_state

  after_transition(:my_state) do ||notification|
    # you can do fancy stuff to a notification when it transitions to a given state
  end

  # TODO: instance eval enum functionality onto a notification instance...?
  # Default is unread: 0, read: 1
  states({
    unread:    0,
    read:      1,
    ignored:   2
  })
end

# in some controller or Anywhere you want to hear some noise
class UserController < ApplicationController
  around_action :slow_yodel, only: :show
  
  def show
    # *snip*
  end

  private

  def slow_yodel
    Yodeler.dispatch 'view.user', {user_id: 3, viewed_user_id: 23]} do
      yield #yield the action dispatch
    end
  end
end

# off in some scorned rails-observer
class UserObserver
  observers :user


  def after_create
    # let the marketing know another thousandth user has registered!
    if (User.count % 1000).zero?
      Yodeler.dispatch :another_thousand_users, {give_him_a_prize: @user.id}
    end
  end
end
```


Getting around the objects
==========================

```ruby
@event.subscriptions #=> Array<Yodeler::Subscription> all subscriber subscriptions
@event.notifications #=> Array<Yodeler::Notifications>
@event.subscribers #=> Array<User,AdminUser,Robot,Puppy> #whatever your 'subscriber' class is, can be more than one type

@notification.subscriber #=> Your 'subscriber' class, delegated to #subscription
@notification.subscription.subscriber
@notification.event #=> The subscriber to event, delegated to #subscription
@notification.message #=> i18n message interpolated w/ the payload

@subscription.subscriber #=> the 'subscriber' subscribed to this event
@subscription.notifications #=> all notifications of this event type for this subscriber
@subscription.event

```

Keep that database lean
=======================
```ruby
Yodeler.cleanup! #marks event types as defunct so they can't
```